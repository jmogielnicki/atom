'use strict';

var recast = require('recast');

var parser = require('acorn-jsx');
var utils = require('./utils');

const log = console.log.bind(console);

const getName = utils.getName;
var opts = require('../parsers/parserOptions')['.js'];
console.log("JAKIE OPCJE", opts);

let allVars = [];

function defineVariable(scope, name, value) {
    scope.vars[name] = value;
    allVars.push({
        scope, name, value
    });
}

function evaluateFunction(chain) {
    const modules = {
        react: {
            Component: {} 
        }
    };

    modules.someModule = analyze(`
        const abc = 1;
        var def = {
            aaa: 1,
            bbb: 2
        };
        def.kotek = 1;
        def.piesek = {
                maly: 1, 
                duzy: {}
            };
        module.exports = {
            abcd: 2
            }            
        `, false).scopes[0].vars; // TODO reverse. now variables are exported and module.exports not

        console.log("JAKAMMMM", modules.someModule);
        console.log("!!", modules.someModule); 
    const functions = {
        require(args) {
            if (modules.hasOwnProperty(args[0].value))
                return modules[args[0].value];
        }
    };
    if (chain.length == 1) {
        const func = chain[0];
        if (functions.hasOwnProperty(func.name)) {
            return functions[func.name](func.arguments);
        }
    } else console.log("!!!!! Za dlugi", chain);
}

const DEFAULT_CODE = require('fs').readFileSync(__dirname + '/mocks/scoper2.js', 'utf8');
function analyze (code, async=true) {
    code = code || DEFAULT_CODE; 
    
    let output = '';
    const log = s => output += s;

    const comments = [];
    var ast = parser.parse(
        code, Object.assign({onComment: comments}, opts)
    );


    const moduleVariable = {
        name: 'module',
        props: {
            exports: {
                name: 'exports'
            }
        }
    };
    let state = {
        stacks: {
            function: [],
            block: [],
            object: [],
            expr: [],
            varScope: []
        },
        global: {
            name: '(global)',
            vars: {
                module: moduleVariable,
                exports:  moduleVariable.props.exports,
            },
            props: Object.create(null),
            start:0,
            end: 1000000,
            loc: {
                start: {
                    line:0, column:0
                },
                end: {
                    line:100000, column:0
                }
                
            }
        },

        // @alias testuj
        current(what) {
            window._info('testuj', [what]);
            const stack = this.stacks[what];
            return stack[stack.length - 1] || this.global;
        },
    };

// state.stacks.function.push(state.global);
// state.stacks.block.push(state.global);



    let result = {
        references: [],
        scopes: [
        ],
        registerScope(obj) {
            this.scopes.push(obj);
        },
        getScopesAt(pos) {
            return this.scopes.filter(scope => {
                return (
                    scope.loc.start.line <= pos.line
                    && scope.loc.end.line >= pos.line
                    // && scope.loc.start.column <= pos.column 
                    // && scope.loc.end.column >= pos.column 
                );
            });
        },
        // @alias findDeclaration
        findDeclaration(pos, name, scopes) {
            if (!name) {
                console.log("BRAK NAZWY", pos, name, scopes);
                return;
            }
            
            console.log("FIND DECLARATION", name);
            window._info('findDeclaration', [[name]]);
            
            let test;
            scopes = scopes || this.getScopesAt(pos);
            for (let i = scopes.length - 1; i >= 0; i--) {
                const vars = scopes[i].vars || Object.create(null);
                const props = scopes[i].props || Object.create(null);

                //8

                
                let decl;
                if (name.charAt(0) == '.') 
                    decl = props[name.slice(1)];
                else
                    decl = vars[name];
                //8

                if (typeof decl != 'undefined') {
                    //window._info('findDeclaration', [[name, decl, state.stacks.block]]);
                    return decl;
                }
            }

            //window._info('findDeclaration', [[name, state.stacks.block]]);
            return test;
        },
        
    };

    result.registerScope(state.global);


    function declarator(ctx, path) {
        const name = getName(path);


        state.stacks.expr.push({
            value: {}
        })

        let scope;
        if (state.current('varScope') == 'function') {
            scope = state.current('function');
        } else {
            scope = state.current('block');
        }

        ctx.traverse(path);
        const expr = state.stacks.expr.pop();

        defineVariable(scope, name, expr.value);


    }

    function beginBlock(path) {

        const block = {
            vars: Object.create(null),
            loc: getLoc(path.node),
            start: path.node.start,
            end: path.node.end,
        };
        state.stacks.block.push(block);

        result.registerScope(block);
    }

    function endBlock() {
        state.stacks.block.pop();
    }


    function getLoc(node) {
        return JSON.parse(JSON.stringify(node.loc));
    }

    function beginFunction (path) {
        const name = getName(path) || getName(path.parent);
        const func = {
            type: 'function',
            name: name,
            vars: Object.create(null),
            loc: getLoc(path.node),
            start: path.node.start,
            end: path.node.end,
        };


        // path.node.params.map(getName).forEach(name => {
        //     defineVariable(func, name, {TODO:true});            
        // });
        path.node.params.forEach(param => {
            const name = getName(param);
            defineVariable(func, name, {
                type: 'argument',
                name,
                loc: getLoc(param),
                start: param.start,
                end: param.end,
            });

        });
        
        
        if (path.node.type == 'FunctionDeclaration') {
            const scope = state.current('function');
            defineVariable(scope, name, func);
        }

        state.stacks.function.push(func);

        state.stacks.block.push(func);

        result.registerScope(func);

    }

    function block(ctx, path) {
        const parent = path.parent.node;
        const blockAlreadyMade = parent.type == 'FunctionExpression' || parent.type == 'FunctionDeclaration';

        if (blockAlreadyMade /* are we sure? */) {
            ctx.traverse(path);
        } else {

            beginBlock(path);
            ctx.traverse(path);
            endBlock(path);
        }
    }

    function visitFunction (path) {
        beginFunction(path);

        this.traverse(path)

        state.current('expr').value = state.stacks.function.pop();
        state.stacks.block.pop();

    }



    recast.visit(ast, {
        visitFunctionExpression: visitFunction,
        visitFunctionDeclaration:visitFunction,
        // visitMethodDefinition(path) {
        //     log("METH")
        //     return false;
        // },
        visitCallExpression(path) {
            console.log("KOL", path.node);
            const chain =  utils.analyzeChain(path.node);
            
            const props = evaluateFunction(chain);

            this.traverse(path);

            if (props) {
                console.log("MODUL!!!", props);
                state.current('expr').value = {
                    name: getName(path) || getName(path.parent),
                    props,
                    loc: getLoc(path.node),
                    start: path.node.start,
                    end: path.node.end,              
                    value: 1,                      
                };                

            }
            
        },
        visitBlockStatement(path) {

            return block(this, path);

        },

        // visitClassDeclaration(path) {
        //     return false;
        // },
        visitVariableDeclarator(path) {
            return declarator(this, path);
        },

        visitVariableDeclaration(path) {
            state.stacks.varScope.push(path.node.kind == 'var'? 'function' : 'block');
            this.traverse(path);
            state.stacks.varScope.pop();
        },

        visitAssignmentExpression(path) {
            const {loc} = path.node;
            
            const chain = utils.analyzeChain(path.node.left);

            state.stacks.expr.push({
                value: {}
            })
            
            if (chain.length == 2) {
                let root = result.findDeclaration(loc.start, chain[0].name);
                if (root) {
                    this.traverse(path);
                    const v = state.stacks.expr.pop().value;

                    (root.props || (root.props = Object.create(null)))[chain[1].name] = v;

                    return;
                }
            }
            this.traverse(path);
            const v = state.stacks.expr.pop().value;
        },


        visitObjectExpression(path) {

            log(`<ul>`)
            // TODO loc, start, end for each entity
            state.stacks.object.push({
                name: getName(path) || getName(path.parent),
                props: Object.create(null),
                loc: getLoc(path.node),
                start: path.node.start,
                end: path.node.end,                
            });
            this.traverse(path);
            const obj = state.stacks.object.pop();
            state.current('expr').value = obj;
            log(`</ul>`)
            
            result.registerScope(obj);
            //return false;
        },
        visitProperty(path) {
            const name = getName(path);

            state.stacks.expr.push({
                value: {
                    loc: getLoc(path.node),
                    start: path.node.start,
                    end: path.node.end,
                    value: path.node.value
                }            
            });
            this.traverse(path);
            state.current('object').props[name] = state.stacks.expr.pop().value || true;
            //return false;
        },
        visitLiteral(path) {
            state.current('expr').value = {
                loc: getLoc(path.node),
                start: path.node.start,
                end: path.node.end,
                value: path.node.value
            };
            this.traverse(path);
        }
    });


    function existsIdentifierWithPos(pos) {
        return false;
        return result.references.find(ref => ref.start == pos.start && ref.end == pos.end);
    }


    let propPath = '';


    function evaluateAssignments() {
        recast.visit(ast, {
            visitAssignmentExpression(path) {
                const {loc} = path.node;
                
                const chain = utils.analyzeChain(path.node.left);
                if (chain.length == 2) {
                    let root = result.findDeclaration(loc.start, chain[0].name);
                    if (root) {
                        console.log("ASSIGNMENT", chain.map(item=>item.name), root, root.props);
                        (root.props || (root.props = Object.create(null)))[chain[1].name] = {
                            name: chain[1].name,
                            props: {
                                maly: {name:'maly'}
                            }                            
                        };
                    }
                }
                this.traverse(path);
            }
        });
    }

//    evaluateAssignments();


    function gatherReferences(ast, scopes, result) {
        recast.visit(ast, {
            visitProperty(path) {
                console.log("PPPPP", path);
                propPath += `.${getName(path.node.key)}`; // TODO!!!!!!!!!!!!!!!!!!!!!!!
                this.traverse(path);

            },
            visitKey(path) {
                
                this.traverse(path);
            },
            visitIdentifier(path) {
                
                const loc = getLoc(path.node);
                const name = path.name == 'key'? '.' + getName(path) : getName(path);
                console.log("KLUCZ", name);
                const decl = result.findDeclaration(loc.start, name);// TODO bug

                if (!existsIdentifierWithPos(path.node))  
                    result.references.push({
                        decl,
                        loc,
                        start: path.node.start,
                        end: path.node.end,
                        name,

                    });
                this.traverse(path);
            },
            visitCallExpression(path) {
                console.log("-----path----",getName(path));
                console.log("-----path----chain",utils.analyzeChain(path.node).map(({name})=>name));
                this.traverse(path);
                //return this.visitMemberExpression(path);
            },
            visitMemberExpression(path) {
                const loc = getLoc(path.node);
                const name = getName(path);
                const chain = utils.analyzeChain(path.node);
                console.log("-----path----chain2",utils.analyzeChain(path.node).map(({name})=>name));

                let root = result.findDeclaration(loc.start, chain[0].name);


                if (root) {
                    chain.forEach((id, i) => {

                        if (i == 0 && !existsIdentifierWithPos(id)) {
                            result.references.push({
                                decl: root,
                                loc: id.loc,
                                start: id.start,
                                end: id.end,
                                name: id.name,

                            });
                            
                            return;   
                        }


                        const prop = root.props && root.props[id.name];
                        if (prop && !existsIdentifierWithPos(id)) {
                            result.references.push({
                                decl: prop,
                                loc: id.loc,
                                start: id.start,
                                end: id.end,
                                name: id.name,

                            });
                            root = prop;
                        } 
                    });

                    
                }

                //this.traverse(path);
                return false;
            }
        });
    }
    

    gatherReferences(ast, result.scopes, result);



    result.aliases = comments.map(comment => {
        const scope = result.scopes.find(scope => scope.start > comment.start);
        const match = comment.value.match(/@alias (\w+)/);

        return {
            name: match && match[1],
            item: scope
        }
    });

    console.log("rrrrrssss", result);
    console.log("ALL VARS", allVars);

    if (async) 
        return new Promise((resolve) => {
            resolve(result);
        });
    else return result;

    
};

exports.analyze = analyze;